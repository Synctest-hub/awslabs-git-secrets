.\" Man page generated from reStructuredText.
.
.TH GIT-SECRETS  "" "" ""
.SH NAME
git-secrets \- 
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
Prevents you from committing passwords and other sensitive information to a
git repository.
.SH SYNOPSIS
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git secrets \-\-install [\-d | \-\-dir <repo>]
git secrets \-\-scan <files>...
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DESCRIPTION
.sp
\fBgit\-secrets\fP scans commits, commit messages, and \fB\-\-no\-ff\fP merges to
prevent adding secrets into your git repositories. If a commit,
commit message, or any commit in a \fB\-\-no\-ff\fP merge history matches one of
your configured prohibited regular expression patterns, then the commit is
rejected.
.SS Installing git\-secrets
.sp
It is recommended to run the \fBinstall.sh\fP script from the
\fI\%git\-secrets\fP repository to install
\fBgit\-secrets\fP\&. \fBinstall.sh\fP will copy \fBgit\-secrets\fP to the appropriate
path (either \fB/usr/local/bin\fP or \fB$(git \-\-exec\-path)\fP), and will ask you
through a series of prompts if you would like to seed you secrets configuration
with common secrets. This includes scanning for AWS credentials, AWS account
IDs, and other pieces of information found in your git config.
.sp
\fBWARNING:\fP
.INDENT 0.0
.INDENT 3.5
You\(aqre not done yet! You MUST install the git hooks for every repo that
you wish to use with \fBgit secrets \-\-install\fP\&.
.UNINDENT
.UNINDENT
.SH OPTIONS
.SS Operation Modes
.sp
Each of these options must appear first on the command line.
.INDENT 0.0
.TP
.B \-\-install
Installs hooks for a repository. Once the hooks are installed for a git
repository, commits and non\-ff merges for that repository will be prevented
from committing secrets.
.sp
Usage: \fBgit secrets \-\-install [\-d | \-\-dir <repo>]\fP
.TP
.B \-\-scan
Scans one or more files for secrets. When a file contains a secret, the
matched text from the file being scanned will be written to stdout and the
script will exit with a non\-zero RC. Each matched line will be written with
the name of the file that matched, a colon, the line number that matched,
a colon, and then the line of text that matched.
.sp
Usage: \fBgit secrets \-\-scan <files>...\fP
.UNINDENT
.SS Options for \fB\-\-install\fP
.INDENT 0.0
.TP
.B \-d\fP,\fB  \-\-dir
When provided, installs git hooks to the given repository. The current
directory is assumed if \fB\-\-dir\fP is not provided.
.sp
The following git hooks are installed:
.INDENT 7.0
.IP 1. 3
\fBpre\-commit\fP: Used to check if any of the files changed in the commit
use prohibited patterns.
.IP 2. 3
\fBcommit\-msg\fP: Used to determine if a commit message contains a
prohibited patterns.
.IP 3. 3
\fBprepare\-commit\-msg\fP: Used to determine if a merge commit will
introduce a history that contains a prohibited pattern at any point.
Please note that this hook is only invoked for non fast\-forward merges.
.UNINDENT
.sp
\fBNOTE:\fP
.INDENT 7.0
.INDENT 3.5
Git only allows a single script to be executed per hook. If the
repository contains Debian style subdirectories like \fBpre\-commit.d\fP
and \fBcommit\-msg.d\fP, then the git hooks will be installed into these
directories, which assumes that you\(aqve configured the corresponding
hooks to execute all of the scripts found in these directories. If
these git subdirectories are not present, then the git hooks will be
installed to the git repo\(aqs \fB\&.git/hooks\fP directory, overwriting any
previously configured hook. In the event that the hooks are
overwritten, a warning will be written to stdout.
.UNINDENT
.UNINDENT
.UNINDENT
.SS Examples
.sp
Install git hooks to the current directory:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
cd /path/to/my/repository
git secrets \-\-install
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Install git hooks to a repository other than the current directory:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git secrets \-\-install \-d /path/to/my/repository
.ft P
.fi
.UNINDENT
.UNINDENT
.SS Options for \fB\-\-scan\fP
.INDENT 0.0
.TP
.B <files>...
The path to one or more files on disk to scan for secrets.
.UNINDENT
.SS Examples
.sp
Scans a file for secrets:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git secrets \-\-scan /path/to/file
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Scans multiple files for secrets:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git secrets \-\-scan /path/to/file /path/to/other/file
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can scan by globbing:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git secrets \-\-scan /path/to/directory/*
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DEFINING PROHIBITED PATTERNS
.sp
egrep compatible regular expressions are used to determine if a commit or
commit message contains any prohibited patterns. These regular expressions are
defined using the \fBgit config\fP command. It is important to note that
different systems use different versions of egrep. For example, when running on
OS X, you will use a different version of egrep than when running on something
like Ubuntu (BSD vs GNU).
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
You can run the \fBinstall.sh\fP script at any time to add a number of
pre\-configured patterns to your list of prohibited regular expressions,
including AWS access keys and known AWS credentials stored in
\fB~/.aws/credentials\fP\&.
.UNINDENT
.UNINDENT
.sp
You can add prohibited regular expression patterns to your git config by
running the following command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-\-add secrets.patterns \(aqmy regex pattern\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
You can list the patterns that have been configured using the following
command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-\-get\-all secrets.patterns
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Patterns will by default be added to the local git repository only. Use the
\fB\-\-global\fP option to add the pattern to your global list of prohibited
patterns:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-\-global \-\-add secrets.patterns \(aqmy regex pattern\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.SH IGNORING FALSE-POSITIVES
.sp
Sometimes a regular expression might match false positives. For example, git
commit SHAs look a lot like AWS access keys. You can specify many different
regular expression patterns as false positives using the following command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-\-add secrets.allowed \(aqmy regex pattern\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
First, git\-secrets will extract all lines from a file that contain a prohibited
match. Included in the matched results will be the full path to the name of
the file that was matched, followed \(aq:\(aq, followed by the line number that was
matched, followed by the entire line from the file that was matched by a secret
pattern. Then, if you\(aqve defined \fBsecrets.allowed\fP regular expressions,
git\-secrets will check to see if all of the matched lines match at least one of
your registered \fBsecrets.allowed\fP regular expressions. If all of the lines
that were flagged as secret are canceled out by an allowed match, then the
subject text does not contain any secrets. If any of the matched lines are not
matched by an allowed regular expression, then git\-secrets will fail the
commit/merge/message.
.sp
\fBIMPORTANT:\fP
.INDENT 0.0
.INDENT 3.5
Just as it is a bad practice to add \fBsecrets.patterns\fP that are too
greedy, it is also a bad practice to add \fBsecrets.allowed\fP patterns that
are too forgiving. Be sure to test out your patterns using ad\-hoc calls to
\fBgit secrets \-\-scan $filename\fP to ensure they are working as intended.
.UNINDENT
.UNINDENT
.SS Example walkthrough
.sp
Let\(aqs take a look at an example. Given the following subject text (stored in
\fB/tmp/example\fP):
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
This is a test!
password=ex@mplepassword
password=******
More test...
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
And the following registered \fBsecrets.patterns\fP and \fBsecrets.allowed\fP:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-\-add secrets.patterns \(aqpassword\es*=\es*.+\(aq
git config \-\-add secrets.allowed \(aqex@mplepassword\(aq
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Running \fBgit secrets \-\-scan /tmp/example\fP, the result will
result in the following error output:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/tmp/example:3:password=******

[ERROR] Matched prohibited pattern

Possible mitigations:

\- Mark false positives as allowed using: git config \-\-add secrets.allowed ...
\- List your configured patterns: git config \-\-get\-all secrets.patterns
\- List your configured allowed patterns: git config \-\-get\-all secrets.allowed
\- Use \-\-no\-verify if this is a one\-time false positive
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Breaking this down, the \fBsecrets.patterns\fP value of \fBpassword\es*=\es*.+\fP
will match the following lines:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
/tmp/example:2:password=ex@mplepassword
/tmp/example:3:password=******
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\&...But the first match will be filtered out due to the fact that it matches the
\fBsecrets.allowed\fP regular expression of \fBex@mplepassword\fP\&. Because
there is still a remaining line that did not match, it is considered a secret.
.sp
Because that matching lines are placed on lines that start with the filename
and line number (e.g., \fB/tmp/example:3:...\fP), you can create
\fBsecrets.allowed\fP patterns that take filenames and line numbers into account
in the regular expression. For example, you could whitelist an entire file
using something like:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-\-add secrets.allowed \(aq/tmp/example:.*\(aq
git secrets \-\-scan /tmp/example && echo $?
# Outputs: 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Alternatively, you could whitelist a specific line number of a file if that
line is unlikely to change using something like the following:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-\-add secrets.allowed \(aq/tmp/example:3:.*\(aq
git secrets \-\-scan /tmp/example && echo $?
# Outputs: 0
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Keep this in mind when creating \fBsecrets.allowed\fP patterns to ensure that
your allowed patterns are not inadvertantly matched due to the fact that the
filename is included in the subject text that allowed patterns are matched
against.
.sp
\fBNOTE:\fP
.INDENT 0.0
.INDENT 3.5
At the implementation level, we use \fBgrep\fP to first extract matches, then
a negative grep using the \fB\-v\fP option to check if all of the extracted
matches were filtered out by an allowed pattern.
.UNINDENT
.UNINDENT
.SS Manually editing your git config
.sp
You may find that it\(aqs easier to simply edit your git config file directly
rather than executing multiple \fBgit config \-\-add\fP commands from the command
line. You can edit a project\(aqs config file using the following command:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
git config \-e
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Simply add a new ini section called "secrets" and place each prohibited
regular expression line using \fBpattern=<regex>\fP\&. For example, your git
config might look something like this:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
[core]
    repositoryformatversion = 0
    filemode = true
    bare = false
    logallrefupdates = true
    ignorecase = true
    precomposeunicode = true
[remote "origin"]
    url = git@github.com:foo/bar
    fetch = +refs/heads/*:refs/remotes/origin/*
[secrets]
    patterns = [A\-Z0\-9]{20}
    patterns = (\e"|\(aq)?(AWS_|aws_)?(SECRET|secret)(_ACCESS|_access)?_(KEY|key)(\e"|\(aq)?\e\es*(=|:|=>)\e\es*(\e"|\(aq)?[A\-Za\-z0\-9/\e\e+=]{40}(\e"|\(aq)?
    patterns = (\e"|\(aq)?(AWS_|aws_)?(ACCOUNT|account)(_ID|_id)?(\e"|\(aq)?\e\es*(=|:|=>)\e\es*(\e"|\(aq)?[0\-9]{4}\e\e\-?[0\-9]{4}\e\e\-?[0\-9]{4}(\e"|\(aq)?
    ; AWS example key
    allowed = AKIAIOSFODNN7EXAMPLE
    ; AWS example secret key
    allowed = wJalrXUtnFEMI/K7MDENG/bPxRfiCYzEXAMPLEKEY
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
More information on git configuration can be found in the
\fI\%git documentation\fP\&.
.SH SKIPPING VALIDATION
.sp
Use the \fB\-\-no\-verify\fP option in the event of a false\-positive match in a
commit, merge, or commit message. This will skip the execution of the
git hook and allow you to make the commit or merge.
.SH ABOUT
.INDENT 0.0
.IP \(bu 2
Author: Michael Dowling <\fI\%https://github.com/mtdowling\fP>
.IP \(bu 2
Issue tracker: This project\(aqs source code and issue tracker can be found at
\fI\%https://github.com/awslabs/git\-secrets\fP
.UNINDENT
.\" Generated by docutils manpage writer.
.
