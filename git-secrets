#!/usr/bin/env bash
declare -r PATTERNS="$(git config --get-all secrets.patterns)"
declare -r ALLOWED_PATTERNS="$(git config --get-all secrets.allowed)"
declare -r PROHIBITED_MSG="\

[ERROR] Matched one or more prohibited patterns

Possible mitigations:

- Mark false positives as allowed using: git config --add secrets.allowed ...
- List your configured patterns: git config --get-all secrets.patterns
- List your configured allowed patterns: git config --get-all secrets.allowed
- Use --no-verify if this is a one-time false positive
"
declare -r NONGIT_OK=1 OPTIONS_SPEC="\
git secrets --scan <files>...
git secrets --install [-d | --dir=<repo>]
--
h,help     Show help message
scan       Scans <files> for prohibited patterns
install    Installs git hooks for repo
d,dir=     Used with --install to specify the path to repo
commit_msg_hook* commit-msg hook (internal only)
pre_commit_hook* pre-commit hook (internal only)
prepare_commit_msg_hook* prepare-commit-msg hook (internal only)"

# Include the git setup script. This parses and normalized CLI arguments.
. $(git --exec-path)/git-sh-setup

scan() {
  local -r file="$1"
  [ -z "${PATTERNS}" ] && return 0
  if [ -z "${ALLOWED_PATTERNS}" ]; then
    # When no allowed patterns are found, we can simply do a search.
    GREP_OPTIONS= LC_ALL=C grep -nwHE "${PATTERNS}" "${file}" && return 1
  else
    # Extract matches then determine with a negative grep if they're allowed.
    GREP_OPTIONS= LC_ALL=C grep -nwHE "${PATTERNS}" "${file}" \
      | GREP_OPTIONS= LC_ALL=C grep -Ev "${ALLOWED_PATTERNS}" && return 1
  fi
  return 0
}

# Scans all of the files in a list. Dies after scanning all if any match.
scan_files() {
  local found_match=0
  for file in $@; do
    # Skip directories
    if [ ! -d "${file}" ]; then
      if [ "${file}" != '-' ] && [ ! -f "${file}" ]; then
        die "File not found: ${file}"
      fi
      scan "$file" || found_match=1
    fi
  done
  [ "$found_match" -eq 0 ] && exit 0
  die "$PROHIBITED_MSG"
}

# Scans a commit message, passed in the path to a file.
commit_msg_hook() {
  scan "$1" || die "$PROHIBITED_MSG"
}

# Scans all files that are about to be committed.
pre_commit_hook() {
  local file found_match=0 rev="4b825dc642cb6eb9a060e54bf8d69288fbee4904"
  # Diff against HEAD if this is not the first commit in the repo.
  [ git rev-parse --verify HEAD >/dev/null 2>&1 ] && rev="HEAD"
  scan_files "$(git diff-index --name-only --cached $rev --)"
}

# Determines if merging in a commit will introduce tainted history.
prepare_commit_msg_hook() {
  case "$2,$3" in
    merge,)
      local git_head=$(env | grep GITHEAD)  # e.g. GITHEAD_<sha>=release/1.43
      local sha="${git_head##*=}"           # Get just the SHA
      local branch=$(git symbolic-ref HEAD) # e.g. refs/heads/master
      local dest="${branch#refs/heads/}"    # cut out "refs/heads"
      say "Checking if merging ${sha} into ${dest} adds prohibited history"
      git log "${dest}".."${sha}" -p \
        | "$0" --scan - || die "$PROHIBITED_MSG"
      ;;
    *) ;;
  esac
}

# Determines the approriate path for a hook to be installed
# This function respects any found $hook.d directories.
determine_hook_install_path() {
  local -r hook="$1" path="$2"
  local dest="${path}/.git/hooks/${hook}"
  local -r debian_dir="${path}/.git/hooks/${hook}.d"
  [ -d "${debian_dir}" ] && dest="${debian_dir}/git-secrets"
  [ -f "$dest" ] && say "[WARN] Overwriting $dest" 1>&2
  echo "$dest"
}

install_hook() {
  local -r dest="$1" name="$2" cmd="$3"
  [ -z "${dest}" ] && die "[ERR]  Expects the path to a file"
  [ -d "$(dirname ${dest})" ] || die "[ERR]  Directory not found: ${dest}"
  echo "#!/usr/bin/env bash" > "${dest}"
  echo "git secrets --${cmd} \"\$@\"" >> "${dest}"
  chmod +x "${dest}"
  say "[OK]   Installed ${name} hook to ${dest}" $'\n'
}

install_all_hooks() {
  local dest git_repo="$1"
  dest=$(determine_hook_install_path "commit-msg" "${git_repo}")
  install_hook "${dest}" "commit-msg" "commit_msg_hook"
  dest=$(determine_hook_install_path "pre-commit" "${git_repo}")
  install_hook "${dest}" "pre-commit" "pre_commit_hook"
  dest=$(determine_hook_install_path "prepare-commit-msg" "${git_repo}")
  install_hook "${dest}" "prepare-commit-msg" "prepare_commit_msg_hook"
  say "Successfully installed git hooks"
}

declare -r COMMAND="$1"; shift

case "${COMMAND}" in
  -h|--help|--) "$0" -h; exit 0 ;;
  --commit_msg_hook|--pre_commit_hook|--prepare_commit_msg_hook)
    # Shift off "--", which was added by git option parsing.
    shift
    # Strip the leading "--" from the hook function name.
    ${COMMAND:2} "$@"
    ;;
  --scan)
    [ "$1" != "--" ] && die "Unexpected argument: $1"
    shift
    [ $# -eq 0 ] && die "No files provided to scan"
    scan_files "$@"
    ;;
  --install)
    [ "$1" == "-d" ] && repo="$2" || repo="."
    [ -d "${repo}" ] || die "Directory not found: ${repo}"
    install_all_hooks "${repo}"
    ;;
  *) echo "Unknown option: ${option}" && "$0" -h ;;
esac
