#!/usr/bin/env bash
declare -r PATTERNS="$(git config --get-all secrets.patterns)"
declare -r ALLOWED_PATTERNS="$(git config --get-all secrets.allowed)"
declare -r MAIN_SPEC="\
usage: git secrets scan [--file=]
   or: git secrets install [--repo=]

   scan       Scans a file for prohibited patterns
   install    Installs git hooks for a repository"

declare -r INSTALL_SPEC="\
git secrets install [(-d | --dir=...)] [-h|--help]

Installs pre-commit and commit-msg hooks for the given repository.
If no repository argument is provided, then the command attempts
to install hooks to a git repository in the working directory.
--
d,dir=      Optional path to a repository for which to install hooks
h,help    show help message"

declare -r SCAN_SPEC="\
git secrets scan (-f | --file ...)

Scans the given file for a list of prohibited patterns.
--
f,file=           Path to a file to scan for secrets. Pass - to scan stdin.
h,help            show help message"

declare -r PROHIBITED_MSG="\

[ERROR] Matched prohibited pattern

Possible mitigations:

- Mark false positives as allowed using: git config --add secrets.allowed ...
- List your configured patterns: git config --get-all secrets.patterns
- List your configured allowed patterns: git config --get-all secrets.allowed
- Use --no-verify if this is a one-time false positive
"

check_pattern() {
  local -r pattern="$1" filename="$2" inverse="$3"
  if [ -z "${inverse}" ]; then
    GREP_OPTIONS= LC_ALL=C grep -nwHE "${pattern}" "${filename}"
  else
    # Extract matches then determine with a negative grep if they're allowed.
    GREP_OPTIONS= LC_ALL=C grep -nwHE "${pattern}" "${filename}" \
      | GREP_OPTIONS= LC_ALL=C grep -Ev "${inverse}"
  fi
}

scan() {
  [ -z "${PATTERNS}" ] && return 0
  if [ -z "${ALLOWED_PATTERNS}" ]; then
    check_pattern "${PATTERNS}" $1 && return 1 || return 0
  fi
  check_pattern "${PATTERNS}" $1 "${ALLOWED_PATTERNS}" && return 1 || return 0
}

commit_msg_hook() {
  scan "$1" || die "(commit-msg)" $'\n' "$PROHIBITED_MSG"
}

# Scans a commit for prohibited patterns.
pre_commit_hook() {
  local file found_match=0 rev="4b825dc642cb6eb9a060e54bf8d69288fbee4904"
  # Diff against HEAD if this is not the first commit in the repo.
  [ git rev-parse --verify HEAD >/dev/null 2>&1 ] && rev="HEAD"
  for file in $(git diff-index --name-only --cached $rev --); do
    scan "$file" || found_match=1
  done
  [ $found_match -eq 0 ] && exit 0
  die "(pre-commit)" $'\n' "$PROHIBITED_MSG"
}

# Determines if merging in a commit will introduce tainted history.
prepare_commit_msg_hook() {
  case "$2,$3" in
    merge,)
      local git_head=$(env | grep GITHEAD)  # e.g. GITHEAD_<sha>=release/1.43
      local sha="${git_head##*=}"           # Get just the SHA
      local branch=$(git symbolic-ref HEAD) # e.g. refs/heads/master
      local dest="${branch#refs/heads/}"    # cut out "refs/heads"
      say "Checking if merging ${sha} into ${dest} adds prohibited history"
      git log "${dest}".."${sha}" -p \
        | "$0" scan -f - || die "(prepare-commit-msg)" $'\n' "$PROHIBITED_MSG"
      ;;
    *) ;;
  esac
}

# Git hook installation functions
#######################################################################

# Determines the approriate path for a hook to be installed
# This function respects any found $hook.d directories.
determine_hook_path() {
  local -r hook="$1" path="$2"
  local dest="${path}/.git/hooks/${hook}"
  local -r debian_dir="${path}/.git/hooks/${hook}.d"
  [ -d "${debian_dir}" ] && dest="${debian_dir}/git-secrets"
  [ -f "$dest" ] && say "[WARN] Overwriting $dest" 1>&2
  echo "$dest"
}

install_hook() {
  local -r dest="$1" name="$2" cmd="$3"
  [ -z "${dest}" ] && die "[ERR]  Expects the path to a file"
  [ -d "$(dirname ${dest})" ] || die "[ERR]  Directory not found: ${dest}"
  echo "#!/usr/bin/env bash" > "${dest}"
  echo "git secrets ${cmd} \"\$@\"" >> "${dest}"
  chmod +x "${dest}"
  say "[OK]   Installed ${name} hook to ${dest}" $'\n'
}

install_hooks() {
  local dest git_repo="$1"
  dest=$(determine_hook_path "commit-msg" "${git_repo}")
  install_hook "${dest}" "commit-msg" "commit_msg_hook"
  dest=$(determine_hook_path "pre-commit" "${git_repo}")
  install_hook "${dest}" "pre-commit" "pre_commit_hook"
  dest=$(determine_hook_path "prepare-commit-msg" "${git_repo}")
  install_hook "${dest}" "prepare-commit-msg" "prepare_commit_msg_hook"
  say "Successfully installed git hooks"
}

# Dispatch to the appropriate functions
#######################################################################

CMD="${1:--h}"; shift
# Determine the approriate options spec and load git-sh helpers.
[ "$CMD" == 'scan' ] && OPTIONS_SPEC="$SCAN_SPEC"
[ "$CMD" == 'install' ] && OPTIONS_SPEC="$INSTALL_SPEC"
NONGIT_OK=1 # Allow the command to run outside of a git repo.
. $(git --exec-path)/git-sh-setup

case "$CMD" in
  scan)
    [ "$1" != '-f' ] && die "-f | --file is required"
    [ "$2" != '-' ] && [ ! -f "$2" ] && die "File not found: $2"
    scan "$2" || die "${PROHIBITED_MSG}"
    ;;
  install)
    case "$1" in
      --) dir=$(git rev-parse --show-toplevel) || die "Not in a git repo" ;;
      -d) dir="$2" ;;
      *) say "Invalid argument"; "$0" install -h; exit 129 ;;
    esac
    [ ! -d "${dir}" ] && die "Directory not found: ${dir}"
    install_hooks "${dir}"
    ;;
  commit_msg_hook|pre_commit_hook|prepare_commit_msg_hook) $CMD "$@" ;;
  -h) printf "$MAIN_SPEC\n" ;;
  *) echo "Unknown command: $CMD" && "$0" -h && exit 129 ;;
esac
