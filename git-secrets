#!/usr/bin/env bash
declare -r PATTERNS="$(git config --get-all secrets.pattern)"
declare -r MAIN_SPEC="\
usage: git secrets scan [--file=]
   or: git secrets install [--repo=]

   scan       Scans a file for prohibited patterns
   install    Installs git hooks for a repository"
declare -r INSTALL_SPEC="\
git secrets install [(-d | --dir=...)] [-h|--help]

Installs pre-commit and commit-msg hooks for the given repository.
If no repository argument is provided, then the command attempts
to install hooks to a git repository in the working directory.
--
d,dir=      Optional path to a repository for which to install hooks
h,help    show help message"
declare -r SCAN_SPEC="\
git secrets scan (-f | --file ...)

Scans the given file for a list of prohibited patterns.
--
f,file=           Path to a file to scan for secrets. Pass - to scan stdin.
h,help            show help message"
declare -r NO_PATTERNS_WARNING_MSG="\
No prohibited patterns have been defined
========================================
You can add prohibited patterns by editing your .git/config file or
by using the following command for each prohibited pattern you wish
to add:

  git config --add secrets.pattern <regex-pattern>

You can list all of the configured prohibited patterns by running
the following command:

  git config --get-all secrets.pattern
"
declare -r PROHIBITED_ERROR_MSG="\

[ERROR] Matched prohibited patterns
"

check_pattern() {
  local pattern="$1" filename="$2" grep_cmd=$(git config --get secrets.grep)
  # Ensure the grep command is valid and executable.
  grep_cmd=$(which "${grep_cmd:-egrep}")
  [ ! -x "$grep_cmd" ] && die "Invalid secrets.grep command: ${grep_cmd}"
  GREP_OPTIONS='' $grep_cmd -nw -H -e "${pattern}" "${filename}"
}

scan() {
  local -r filename="$1"
  if [ -z "$PATTERNS" ]; then
    say "$NO_PATTERNS_WARNING_MSG"
  else
    check_pattern "$PATTERNS" "${filename}" && return 1
  fi
  return 0
}

commit_msg_hook() {
  scan "$1" || die "(commit-msg)" $'\n' "$PROHIBITED_ERROR_MSG"
}

# NOTE: This is based on git's pre-commit.sample script.
# Allows the hook to reject commits for brand new repos.
determine_rev_to_diff() {
  [ git rev-parse --verify HEAD >/dev/null 2>&1 ] \
    && "HEAD" || echo "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
}

# Scans a commit for prohibited patterns.
pre_commit_hook() {
  local file found_match=0 against=$(determine_rev_to_diff)
  local changes=$(git diff-index --name-status --cached $against -- | cut -c3-)
  found_match=0
  for file in $changes; do
    scan "$file" || found_match=1
  done
  [ $found_match -eq 1 ] && die "(pre-commit)" $'\n' "$PROHIBITED_ERROR_MSG"
}

# Determines if merging in a commit will introduce tainted history.
prepare_commit_msg_hook() {
  case "$2,$3" in
    merge,)
      local git_head=$(env | grep GITHEAD)  # e.g. GITHEAD_<sha>=release/1.43
      local sha="${git_head##*=}"           # Get just the SHA
      local branch=$(git symbolic-ref HEAD) # e.g. refs/heads/master
      local dest="${branch#refs/heads/}"    # cut out "refs/heads"
      echo "Checking if merging ${sha} into ${dest} adds prohibited history"
      git log "${dest}".."${sha}" -p \
        | "$0" scan -f - -n \
        || die "(prepare-commit-msg)" $'\n' "$PROHIBITED_ERROR_MSG"
      ;;
    *) ;;
  esac
}

# Git hook installation functions
#######################################################################

# Determines the approriate path for a hook to be installed
# This function respects any found $hook.d directories.
determine_hook_path() {
  local -r hook="$1" path="$2"
  local dest="${path}/.git/hooks/${hook}"
  local -r debian_dir="${path}/.git/hooks/${hook}.d"
  [ -d "${debian_dir}" ] && dest="${debian_dir}/git-secrets"
  [ -f "$dest" ] && say "[WARN] Overwriting $dest" 1>&2
  echo "$dest"
}

install_hook() {
  local -r dest="$1" name="$2" cmd="$3"
  [ -z "${dest}" ] && die "[ERR]  Expects the path to a file"
  [ -d "$(dirname ${dest})" ] || die "[ERR]  Directory not found: ${dest}"
  echo "#!/usr/bin/env bash" > "${dest}"
  echo "git secrets ${cmd} \"\$@\"" >> "${dest}"
  chmod +x "${dest}"
  say "[OK]   Installed ${name} hook to ${dest}" $'\n'
}

install_hooks() {
  local dest git_repo="$1"
  dest=$(determine_hook_path "commit-msg" "${git_repo}")
  install_hook "${dest}" "commit-msg" "commit_msg_hook"
  dest=$(determine_hook_path "pre-commit" "${git_repo}")
  install_hook "${dest}" "pre-commit" "pre_commit_hook"
  dest=$(determine_hook_path "prepare-commit-msg" "${git_repo}")
  install_hook "${dest}" "prepare-commit-msg" "prepare_commit_msg_hook"
  say "Successfully installed git hooks"
}

# Dispatch to the appropriate functions
#######################################################################

COMMAND="${1:--h}"
NONGIT_OK=1
LOAD_GIT="$(git --exec-path)/git-sh-setup"
shift

case "$COMMAND" in
  -h) printf "$MAIN_SPEC\n" && exit 0 ;;
  commit_msg_hook|pre_commit_hook|prepare_commit_msg_hook)
    . $LOAD_GIT
    $COMMAND "$@"
    exit 0
    ;;
  scan)
    OPTIONS_SPEC="$SCAN_SPEC"
    . $LOAD_GIT
    [ -z "$2" ] && die "-f | --file is required"
    [ "$2" != '-' ] && [ ! -f "$2" ] && die "File not found: $2"
    scan "$2" || die "$PROHIBITED_ERROR_MSG"
    ;;
  install)
    OPTIONS_SPEC="$INSTALL_SPEC"
    . $LOAD_GIT
    case "$1" in
      --) dir=$(git rev-parse --show-toplevel) || die "Not in a git repo" ;;
      -d|--dir) dir="$2" ;;
      *) say "Invalid argument"; "$0" install -h; exit 129 ;;
    esac
    [ ! -d "${dir}" ] && die "Directory not found: ${dir}"
    install_hooks "${dir}"
    ;;
  *) echo "Unknown command: $COMMAND" && "$0" -h && exit 129 ;;
esac
