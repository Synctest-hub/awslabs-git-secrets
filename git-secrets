#!/usr/bin/env bash
declare -r PATTERNS="$(git config --get-all secrets.pattern)"
declare -r MAIN_SPEC="\
usage: git secrets scan [--file=]
   or: git secrets install [--repo=]

   scan       Scans a file for prohibited patterns
   install    Installs git hooks for a repository"
declare -r INSTALL_SPEC="\
git-secrets install [(-d | --dir=...)] [-h|--help]

Installs pre-commit and commit-msg hooks for the given repository.
If no repository argument is provided, then the command attempts
to install hooks to a git repository in the working directory.
--
d,dir=      Optional path to a repository for which to install hooks
h,help    show help message"
declare -r SCAN_SPEC="\
git-secrets scan (-f | --file ...) [-n|--non-interactive]

Scans the given file for a list of prohibited patterns.
--
f,file=           Path to a file to scan for secrets. Pass - to scan stdin.
n,non-interactive Do not prompt for user input intervention on failures.
h,help            show help message"
declare -r NO_PATTERNS_WARNING_MSG="\
No prohibited patterns have been defined
========================================
You can add prohibited patterns by editing your .git/config file or
by using the following command for each prohibited pattern you wish
to add:

  git config --add secrets.pattern <regex-pattern>

You can list all of the configured prohibited patterns by running
the following command:

  git config --get-all secrets.pattern
"
declare -r PROHIBITED_ERROR_MSG="\

[ERROR] Matched prohibited patterns
"

warn_if_no_patterns() {
  [ -z "$PATTERNS" ] && say "$NO_PATTERNS_WARNING_MSG"
}

check_pattern() {
  local pattern="$1" filename="$2" grep_cmd=$(git config --get secrets.grep)
  # Ensure the grep command is valid and executable.
  grep_cmd=$(which "${grep_cmd:-egrep}")
  [ ! -x "$grep_cmd" ] && die "Invalid secrets.grep command: ${grep_cmd}"
  GREP_OPTIONS='' $grep_cmd -nw -H -e "${pattern}" "${filename}"
}

should_fail() {
  local pattern=$1 file=$2
  local -r affirmative="Yes: this is a false positive, allow it and continue."
  local -r negative="No: this is a secret. Do not commit it and stop."
  echo $'\n'"^^^ Matched prohibited pattern in ${file}: ${pattern}"
  echo "Do you wish to commit this anyway?"
  select yn in "${negative}" "${affirmative}"; do
    case $yn in
      [nN]*) return 0 ;;
      [Y]*) echo; return 1 ;;
    esac
  done
}

scan() {
  local -r filename="$1"
  warn_if_no_patterns
  if [ ! -z "$PATTERNS" ]; then
    if [ $IS_INTERACTIVE -eq 0 ]; then
      # Check will all patterns at once
      check_pattern "$PATTERNS" "${filename}" && die "$PROHIBITED_ERROR_MSG"
    else
      # Check each pattern individually for user prompts.
      local found_errors=0
      for pattern in $PATTERNS; do
        if check_pattern "${pattern}" "${filename}"; then
          should_fail "${pattern}" "${filename}" && die "$PROHIBITED_ERROR_MSG"
        fi
      done
    fi
  fi
}

commit_msg_hook() {
  scan "$1"
}

# NOTE: This is based on git's pre-commit.sample script.
# Allows the hook to reject commits for brand new repos.
determine_rev_to_diff() {
  [ git rev-parse --verify HEAD >/dev/null 2>&1 ] \
    && "HEAD" || echo "4b825dc642cb6eb9a060e54bf8d69288fbee4904"
}

# Scans a commit for prohibited patterns.
pre_commit_hook() {
  local file found_match=0 against=$(determine_rev_to_diff)
  local changes=$(git diff-index --name-status --cached $against -- | cut -c3-)
  for file in $changes; do
    scan "$file"
  done
}

# Determines if merging in a commit will introduce tainted history.
prepare_commit_msg_hook() {
  case "$2,$3" in
    merge,)
      local git_head=$(env | grep GITHEAD)  # e.g. GITHEAD_<sha>=release/1.43
      local sha="${git_head##*=}"           # Get just the SHA
      local branch=$(git symbolic-ref HEAD) # e.g. refs/heads/master
      local dest="${branch#refs/heads/}"    # cut out "refs/heads"
      echo "Checking if merging ${sha} into ${dest} adds prohibited history"
      git log "${dest}".."${sha}" -p | "$0" scan -f -
      ;;
    *) ;;
  esac
}

# Git hook installation functions
#######################################################################

# Determines the approriate path for a hook to be installed
# This function respects any found $hook.d directories.
determine_hook_path() {
  local -r hook="$1" path="$2"
  local dest="${path}/.git/hooks/${hook}"
  local -r debian_dir="${path}/.git/hooks/${hook}.d"
  [ -d "${debian_dir}" ] && dest="${debian_dir}/git-secrets"
  [ -f "$dest" ] && say "[WARN] Overwriting $dest" 1>&2
  echo "$dest"
}

install_hook() {
  local -r dest="$1" name="$2" cmd="$3"
  [ -z "${dest}" ] && die "[ERR]  Expects the path to a file"
  [ -d "$(dirname ${dest})" ] || die "[ERR]  Directory not found: ${dest}"
  echo "#!/usr/bin/env bash" > "${dest}"
  echo "git secrets ${cmd} \"\$@\"" >> "${dest}"
  chmod +x "${dest}"
  say "[OK]   Installed ${name} hook to ${dest}" $'\n'
}

install_hooks() {
  local dest git_repo="$1"
  dest=$(determine_hook_path "commit-msg" "${git_repo}")
  install_hook "${dest}" "commit-msg" "commit_msg_hook"
  dest=$(determine_hook_path "pre-commit" "${git_repo}")
  install_hook "${dest}" "pre-commit" "pre_commit_hook"
  dest=$(determine_hook_path "prepare-commit-msg" "${git_repo}")
  install_hook "${dest}" "prepare-commit-msg" "prepare_commit_msg_hook"
  say "Successfully installed git hooks"
}

# Dispatch to the appropriate functions
#######################################################################

if [ "$(git config --get secrets.non-interactive)" -eq 1 ]; then
  IS_INTERACTIVE=0
else
  exec < /dev/tty
  [[ -t 0 && -t 1 ]] && declare -r IS_ATTY=1 || declare -r IS_ATTY=0
  IS_INTERACTIVE=$IS_ATTY
fi

COMMAND="${1:--h}"
NONGIT_OK=1
LOAD_GIT="$(git --exec-path)/git-sh-setup"
shift

case "$COMMAND" in
  -h) printf "$MAIN_SPEC\n" && exit 0 ;;
  commit_msg_hook|pre_commit_hook|prepare_commit_msg_hook)
    . $LOAD_GIT
    $COMMAND "$@"
    exit 0
    ;;
  scan)
    OPTIONS_SPEC="$SCAN_SPEC"
    . $LOAD_GIT
    declare file
    while [ $# -gt 0 ]; do
      case "$1" in
        -f) shift; file="$1"; shift ;;
        -n) shift; IS_INTERACTIVE=0 ;;
        --) break ;;
      esac
    done
    [ -z "$file" ] && die "-f | --file is required"
    [ "$file" != '-' ] && [ ! -f "$file" ] && die "File not found: $file"
    scan "$file"
    exit 0
    ;;
  install)
    OPTIONS_SPEC="$INSTALL_SPEC"
    . $LOAD_GIT
    case "$1" in
      --) dir=$(git rev-parse --show-toplevel) || die "Not in a git repo" ;;
      -d|--dir) dir="$2" ;;
      *) say "Invalid argument"; "$0" install -h; exit 129 ;;
    esac
    [ ! -d "${dir}" ] && die "Directory not found: ${dir}"
    install_hooks "${dir}"
    ;;
  *) echo "Unknown command: $COMMAND" && "$0" -h && exit 129 ;;
esac
